<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>JavaScript Cheat Sheet</title>
  <meta name="format-detection" content="telephone=no">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <!-- Favicon -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="icon" href="images/favicon/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="images/favicon/favicon.ico" type="image/x-icon">
  <!-- Styles -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">
  <link rel="stylesheet" href="css/styles.css">
  <script src="https://kit.fontawesome.com/7cff9dd751.js" crossorigin="anonymous"></script>
</head>
<body>
  <div id="wrapper">
    <!-- header begin -->
    <header id="header">
      <h1 class="logo-js">JavaScript Cheat Sheet</h1>
      <button class="btn-menu"></button>
      <nav>
        <ul>
          <li><a href="https://learn.javascript.ru/" target="_blank">Учебник</a></li>
          <li><a href="http://jsbin.com/?html,css,js,console,output" target="_blank">Редактор</a></li>
          <li class="dropdown">
            <a class="dropdown-toggle" href="#" data-bs-toggle="dropdown" aria-expanded="false">Webpack</a>
            <ul class="dropdown-menu">
              <li><a class="dropdown-item" href="#">Webpack сборка 2023</a></li>
              <li><a class="dropdown-item" href="#">Webpack сайт</a></li>
              <li><a class="dropdown-item" href="#">Webpack конспект</a></li>
            </ul>
          </li>
        </ul>
      </nav>
    </header>
    <!-- header end -->
    <!-- main content begin -->
    <main id="main">

      <div class="all-opener-row">
        <a class="btn btn-outline-secondary all-section-open" href="#">Раскрыть все секции</a>
        <a class="btn btn-outline-secondary all-section-close" href="#">Закрыть все секции</a>
      </div>

      <div class="data-row grid">
        <div class="grid-item">
          <div class="block">
            <div class="heading" data-bs-toggle="collapse" data-bs-target="#collapseBase">
              <h2>Базовая информация</h2>
            </div>
            <div class="collapse show" id="collapseBase">
              <h3>Скрипт на странице</h3>
              <div class="item">
                <pre>&lt;<span>script</span> <span>type</span>=<span>"text/javascript"</span>>  ...
&lt;/<span>script</span>></pre>
              </div>
              <h3>Подключение внешнего js файла</h3>
              <div class="item">
                <pre><span>&lt;<span>script</span> <span>src</span>=<span>"filename.js"</span>>&lt;/<span>script</span>></span></pre>
              </div>
              <h3>Задержка 1 сек</h3>
              <div class="item">
                <pre>setTimeout(function () {
...
}, 1000);</pre>
              </div>
              <h3>Функции</h3>
              <div class="item">
                <pre>function addNumbers(a, b) {
return a + b; ;
}
x = addNumbers(1, 2);</pre>
              </div>
              <h3>Редактирование DOM элемента</h3>
              <div class="item">
                <pre>document.getElementById("elementID").innerHTML = "Hello World!";</pre>
              </div>
              <h3>Вывод информации</h3>
              <div class="item">
                <pre>console.log(a);             // вывод в консоль браузера
document.write(a);          // вывод в HTML
alert(a);                   // вывод в alert окне
confirm("Really?");         // yes/no диалог, возвращяет true/false
prompt("Your age?","0");    // диалог с полем ввода. Второй аргумент - значение по умолчанию</pre>
              </div>
              <h3>Комментарии</h3>
              <div class="item">
                <pre>/* Multi line
comment */
// One line</pre>
              </div>
            </div>
          </div>
        </div>

        <div class="grid-item">
          <div class="block">
            <div class="heading" data-bs-toggle="collapse" data-bs-target="#collapseVariables">
              <h2>Переменные</h2>
            </div>
            <div class="collapse show" id="collapseVariables">
              <div class="item">
                <pre>var a;                       // var - variable</pre>
                <!-- example and info buttons begin -->
                <div class="buttons">
                  <button class="btn btn-more" data-bs-toggle="modal" data-bs-target="#varInfoModal" data-toggle="tooltip" title="Больше информации">
                    <i class="fas fa-question"></i>
                  </button>
                </div>
                <!-- example and info buttons end -->
                <!-- modal window begin -->
                <div class="modal fade" id="varInfoModal" tabindex="-1" aria-hidden="true">
                  <div class="modal-dialog">
                    <div class="modal-content">
                      <div class="modal-header">
                        <h3>Объявление переменной с помощью "var"</h3>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                      </div>
                      <div class="modal-body">
                        <p>Основное отличие объявление переменной с помощью <strong>var</strong> - это область видимости такой переменной.</p>
                        <p>Для <strong>var</strong> не существует блочной области видимости.</p>
                        <p>Если переменная создаётся внутри объявления функции, то её область видимости определяется как локальная и ограничивается этой функцией (т.е. будет доступна только внутри этой функции и вложенных в неё функциях).</p>
                        <p>Если такие переменные используются внутри цикла <strong>for</strong> или проверки <strong>if</strong>, то они будут видны и за пределами этих блоков.</p>
                        <pre>
if (true) {
  var test = true; // используем var вместо let
}

alert(test); // true, переменная существует вне блока if</pre>
                        <pre>
for (var i = 0; i < 10; i++) {
  // ...
}

alert(i); // 10, переменная i доступна вне цикла, т.к. является глобальной переменной</pre>
                        <pre>
function sayHi() {
  if (true) {
    var phrase = "Привет";
  }

  alert(phrase); // срабатывает и выводит "Привет"
}

sayHi();
alert(phrase); // Ошибка: phrase не определена (видна в консоли разработчика)</pre>
                        <p>Если переменная объявляется не внутри функции, то она считается глобальной и ограничивается скриптом.</p>
                        <h4>«var» допускает повторное объявление</h4>
                        <p>Если в блоке кода дважды объявить одну и ту же переменную <strong>let</strong>, будет ошибка. Используя <strong>var</strong>, можно переобъявлять переменную сколько угодно раз. Повторные <strong>var</strong> игнорируются:</p>
                        <pre>
var user = "Pete";

var user; // ничего не делает, переменная объявлена раньше
// ...нет ошибки

alert(user); // Pete</pre>
                        <p>Если дополнительно присвоить значение, то переменная примет новое значение:</p>
                        <pre>
var user = "Pete";

var user = "John";

alert(user); // John</pre>
                        <h4>«var» обрабатываются в начале запуска функции</h4>
                        <p>Объявления переменных <strong>var</strong> обрабатываются в начале выполнения функции (или запуска скрипта, если переменная является глобальной).</p>
                        <p>Другими словами, переменные <strong>var</strong> считаются объявленными с самого начала исполнения функции вне зависимости от того, в каком месте функции реально находятся их объявления (при условии, что они не находятся во вложенной функции).</p>
                        <p>Необходимо помнить, что объявления переменных «всплывают», но присваивания значений – нет.</p>
                        <p>Объявление переменной обрабатывается в начале выполнения функции («всплывает»), однако присвоение значения всегда происходит в той строке кода, где оно указано. Т.е. код выполняется по следующему сценарию:</p>
                        <pre>
function sayHi() {
  var phrase; // объявление переменной срабатывает вначале...

  alert(phrase); // undefined

  phrase = "Привет"; // ...присвоение - в момент, когда исполнится данная строка кода.
}

sayHi();</pre>
                        <p>Поскольку все объявления переменных <strong>var</strong> обрабатываются в начале функции, мы можем ссылаться на них в любом месте. Однако, переменные имеют значение <strong>undefined</strong> до строки с присвоением значения.</p>
                        <h4>Имена переменных</h4>
                        <p>В JavaScript есть два ограничения, касающиеся имён переменных:</p>
                        <ul>
                          <li>Имя переменной должно содержать только буквы, цифры или символы <strong>$</strong> и <strong>_</strong>.</li>
                          <li>Первый символ не должен быть цифрой.</li>
                        </ul>
                        <p></p>
                        <p>Регистр также имеет значение. Переменные с именами <strong>apple</strong> и <strong>APPLE</strong> – это две разные переменные</p>
                        <p>Также существует <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0" target="_blank">список зарезервированных слов</a>, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.</p>
                      </div>
                    </div>
                  </div>
                </div>
                <!-- modal window end -->
              </div>
              <div class="item"><pre>var a = 1, b = 2, c = a + b; // объявление в одну строку</pre></div>
              <div class="item">
                <pre>let z = 'zzz';               // блочная область видимости </pre>
                <!-- example and info buttons begin -->
                <div class="buttons">
                  <button class="btn btn-more" data-bs-toggle="modal" data-bs-target="#letInfoModal" data-toggle="tooltip" title="Больше информации">
                    <i class="fas fa-question"></i>
                  </button>
                </div>
                <!-- example and info buttons end -->
                <!-- modal window begin -->
                <div class="modal fade" id="letInfoModal" tabindex="-1" aria-hidden="true">
                  <div class="modal-dialog">
                    <div class="modal-content">
                      <div class="modal-header">
                        <h3>Объявление переменной с помощью "let"</h3>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                      </div>
                      <div class="modal-body">
                        <p>Ключевое слово <strong>let</strong> используется для создания переменной, значение которой может меняться.</p>
                        <p>Приведённая ниже инструкция создаёт (другими словами, объявляет) переменную с именем «message»:</p>
                        <pre>let message;</pre>
                        <p>Теперь можно поместить в неё данные (другими словами, определить переменную), используя оператор присваивания =:</p>
                        <pre>let message;

message = 'Hello'; // сохранить строку 'Hello' в переменной с именем message</pre>
                        <p>Для краткости можно совместить объявление переменной и запись данных в одну строку:</p>
                        <pre>let message = 'Hello!'; // определяем переменную и присваиваем ей значение

alert(message); // Hello!</pre>
                        <p>Мы также можем объявить несколько переменных в одной строке:</p>
                        <pre>let user = 'John', age = 25, message = 'Hello';</pre>
                        <p>Многострочный вариант немного длиннее, но легче для чтения. Рекомендуется использовать его для лучшей читаемости):</p>
                        <pre>let user = 'John';
let age = 25;
let message = 'Hello';</pre>
                        <p>Некоторые люди также определяют несколько переменных в таком вот многострочном стиле:</p>
                        <pre>let user = 'John',
  age = 25,
  message = 'Hello';</pre>
                        <h4>Повторное объявление вызывает ошибку</h4>
                        <p>Переменная может быть объявлена только один раз.</p>
                        <p>Повторное объявление той же переменной является ошибкой:</p>
                        <pre>let message = "Это";

let message = "Другое"; // SyntaxError: 'message' has already been declared</pre>
                        <h4>Блочная область видимости</h4>
                        <p>Главное отличие <strong>let</strong> в том, что область видимости переменной ограничивается блоком, а не функцией.</p>
                        <p>Другими словами, переменная, созданная с помощью оператора <strong>let</strong>, доступна внутри блока, в котором она была создана и в любом вложенном блоке.</p>
                        <p>Говоря «блок», я имею ввиду всё что вложено между фигурными скобками <strong>{}</strong>, как например в цикле <strong>for</strong> или условии <strong>if</strong>.</p>
                        <h4>Имена переменных</h4>
                        <p>В JavaScript есть два ограничения, касающиеся имён переменных:</p>
                        <ul>
                          <li>Имя переменной должно содержать только буквы, цифры или символы <strong>$</strong> и <strong>_</strong>.</li>
                          <li>Первый символ не должен быть цифрой.</li>
                        </ul>
                        <p></p>
                        <p>Регистр также имеет значение. Переменные с именами <strong>apple</strong> и <strong>APPLE</strong> – это две разные переменные</p>
                        <p>Также существует <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0" target="_blank">список зарезервированных слов</a>, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.</p>
                      </div>
                    </div>
                  </div>
                </div>
                <!-- modal window end -->
              </div>
              <div class="item">
                <pre>const PI = 3.14;             // константа</pre>
                <!-- example and info buttons begin -->
                <div class="buttons">
                  <button class="btn btn-more" data-bs-toggle="modal" data-bs-target="#constInfoModal" data-toggle="tooltip" title="Больше информации">
                    <i class="fas fa-question"></i>
                  </button>
                </div>
                <!-- example and info buttons end -->
                <!-- modal window begin -->
                <div class="modal fade" id="constInfoModal" tabindex="-1" aria-hidden="true">
                  <div class="modal-dialog">
                    <div class="modal-content">
                      <div class="modal-header">
                        <h3>Объявление переменной с помощью "const"</h3>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                      </div>
                      <div class="modal-body">
                        <p>Переменные, объявленные с помощью <strong>const</strong>, называются «константами». Их нельзя изменить. Попытка сделать это приведёт к ошибке:</p>
                        <h4>Константы в верхнем регистре</h4>
                        <p>Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.</p>
                        <p>Названия таких констант пишутся с использованием заглавных букв и подчёркивания.</p>
                        <pre>const COLOR_RED = "#F00";
const COLOR_ORANGE = "#FF7F00";

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE;
alert(color); // #FF7F00</pre>
                        <p>Eсть константы, которые известны до выполнения (например, шестнадцатеричное значение для красного цвета), а есть константы, которые вычисляются во время выполнения сценария, но не изменяются после их первоначального назначения.</p>
                        <p>Вычисляемые константы прописываются обычными, не прописными буквами.</p>
                        <p>Другими словами, константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений.</p>
                        <h4>Блочная область видимости</h4>
                        <p>Главное отличие <strong>const</strong> (как и <strong>let</strong>) в том, что область видимости переменной ограничивается блоком, а не функцией.</p>
                        <p>Другими словами, переменная, созданная с помощью оператора <strong>const</strong>, доступна внутри блока, в котором она была создана и в любом вложенном блоке.</p>
                        <p>Говоря «блок», я имею ввиду всё что вложено между фигурными скобками <strong>{}</strong>, как например в цикле <strong>for</strong> или условии <strong>if</strong>.</p>
                        <h4>Имена переменных</h4>
                        <p>В JavaScript есть два ограничения, касающиеся имён переменных:</p>
                        <ul>
                          <li>Имя переменной должно содержать только буквы, цифры или символы <strong>$</strong> и <strong>_</strong>.</li>
                          <li>Первый символ не должен быть цифрой.</li>
                        </ul>
                        <p></p>
                        <p>Регистр также имеет значение. Переменные с именами <strong>apple</strong> и <strong>APPLE</strong> – это две разные переменные</p>
                        <p>Также существует <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0" target="_blank">список зарезервированных слов</a>, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.</p>
                      </div>
                    </div>
                  </div>
                </div>
                <!-- modal window end -->
              </div>
              <div class="item">
                <pre>let b = "init";              // строка string</pre>
              </div>
              <div class="item">
                <pre>let c = "Hi" + " " + "Joe";  // = "Hi Joe"</pre>
              </div>
              <div class="item">
                <pre>let d = 1 + 2 + "3";         // = "33"</pre>
              </div>
              <div class="item">
                <pre>let e = [2,3,5,8];           // массив array</pre>
              </div>
              <div class="item">
                <pre>let f = false;               // логический тип boolean</pre>
              </div>
              <div class="item">
                <pre>let g = /()/;                // регулярное выражение RegEx</pre>
              </div>
              <div class="item">
                <pre>let h = function(){};        // функция function object</pre>
              </div>
              <div class="item">
                <pre>let user = new Object();     // синтаксис "конструктор объекта"</pre>
              </div>
              <div class="item">
                <pre>let user = {};               // синтаксис "литерал объекта"</pre>
              </div>
              <div class="item">
                <pre>let inf = Infinity;          // бесконечность ∞</pre>
              </div>
              <h3>Строгий режим</h3>
              <div class="item">
                <pre>"use strict";   // включает строгий режим для написания безопасного кода
x = 1;          // будет ошибка - переменная не была объявлена</pre>
              </div>
              <h3>Значения</h3>
              <div class="item">
                <pre>false, true                     // логические boolean</pre>
              </div>
              <div class="item">
                <pre>18, 3.14, 0b10011, 0xF6, NaN    // числа number</pre>
              </div>
              <div class="item">
                <pre>"flower", 'John'                // строки string</pre>
              </div>
              <div class="item">
                <pre>undefined, null , Infinity      // специальные special</pre>
              </div>
            </div>
          </div>
        </div>

        <div class="grid-item">
          <div class="block">
            <div class="heading" data-bs-toggle="collapse" data-bs-target="#collapseDataTypes">
              <h2>Типы данных</h2>
            </div>
            <div class="collapse show" id="collapseDataTypes">
              <h3>Простые типы</h3>
              <div class="item">
                <pre>let age = 18;                           // число number</pre>
              </div>
              <div class="item">
                <pre>let nul = 0xff;                         // 255, "0x" - 16-ричное число</pre>
              </div>
              <div class="item">
                <pre>let nul = 0o377;                        // 255, "0o" - 8-ричное число</pre>
              </div>
              <div class="item">
                <pre>let nul = 0b11111111;                   // 255, "0b" - двоичное число</pre>
              </div>
              <div class="item">
                <pre>let inf = Infinity;                     // бесконечность ∞, number / 0</pre>
              </div>
              <div class="item">
                <pre>let name = "Jane";                      // строка string</pre>
              </div>
              <div class="item">
                <pre>let truth = false;                      // логический тип boolean</pre>
              </div>
              <div class="item">
                <pre>let id = Symbol("id");                  // символ Symbol</pre>
              </div>
              <div class="item">
                <pre>let bigint = BigInt("123456789012345")  // BigInt</pre>
              </div>
              <h3>Специальные значения</h3>
              <div class="item">
                <pre>let age = null;                         // Null</pre>
              </div>
              <div class="item">
                <pre>let a; typeof a; let age = undefined;   // undefined</pre>
              </div>
              <h3>Объекты</h3>
              <div class="item">
                <pre>let name = {first:"Jane", last:"Doe"};  // объект object</pre>
              </div>
              <div class="item">
                <pre>let user = new Object();                // конструктор объекта</pre>
              </div>
              <h3>Специальные объекты</h3>
              <div class="item">
                <pre>let sheets = ["HTML","CSS","JS"];       // массив array</pre>
              </div>
              <div class="item">
                <pre>let now = new Date();                   // объект даты</pre>
              </div>
              <div class="item">
                <pre>let h = function(){};                   // функции function</pre>
              </div>
              <div class="item">
                <pre>let re = /ab+c/;                        // регулярные выражения</pre>
              </div>
              <div class="item">
                <pre>let re = new RegExp("ab+c");            // регулярные выражения</pre>
              </div>
              <div class="item">
                <pre>const x = Error("Error here!");         // объект ошибки</pre>
              </div>
            </div>
          </div>
        </div>

        <div class="grid-item">
          <div class="block">
            <div class="heading" data-bs-toggle="collapse" data-bs-target="#collapseTypeConversion">
              <h2>Преобразование типов</h2>
            </div>
            <div class="collapse show" id="collapseTypeConversion">
              <h3>Строковое преобразование</h3>
              <div class="item">
                <pre>let value = true; // boolean
value = String(value); // теперь value это строка "true"</pre>
              </div>
              <div class="item">
                <pre>let value = 123 + '27' // 12327 тут конкатенация строк</pre>
              </div>
              <h3>Численное преобразование</h3>
              <p>Численное преобразование происходит в математических функциях и выражениях (кроме знака конкатенации <strong>+</strong>).</p>
              <div class="item">
                <pre>let value = "6" / "2"; // 3, строки преобразуются в числа</pre>
              </div>
              <div class="item">
                <pre>let value = "125" * 2; // 250, строки преобразуются в числа</pre>
              </div>
              <p>Мы можем использовать функцию <strong>Number(value)</strong>, чтобы явно преобразовать <strong>value</strong> к числу:</p>
              <div class="item">
                <pre>let str = "123"; // string
let num = Number(str); // становится числом 123</pre>
              </div>
              <p>Правила численного преобразования:</p>
              <table>
                <tr>
                  <th>Значение</th>
                  <th>Преобразуется в</th>
                </tr>
                <tr>
                  <td><strong>undefined</strong></td>
                  <td><strong>NaN</strong></td>
                </tr>
                <tr>
                  <td><strong>null</strong></td>
                  <td><strong>0</strong></td>
                </tr>
                <tr>
                  <td><strong>true / false</strong></td>
                  <td><strong>1 / 0</strong></td>
                </tr>
                <tr>
                  <td><strong>string</strong></td>
                  <td>Пробельные символы (пробелы, знаки табуляции <strong>\t</strong>, знаки новой строки <strong>\n</strong> и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем <strong>0</strong>, иначе из непустой строки «считывается» число. При ошибке результат <strong>NaN</strong>.</td>
                </tr>
              </table>
              <p>Примеры:</p>
              <div class="item">
                <pre>let value = Number("   123   "); // 123</pre>
              </div>
              <div class="item">
                <pre>let value = Number("123z");      // NaN</pre>
              </div>
              <div class="item">
                <pre>let value = Number(true);        // 1</pre>
              </div>
              <div class="item">
                <pre>let value = Number(false);       // 0</pre>
              </div>
              <p class="warning"><strong>undefined</strong> при численном преобразовании становится <strong>NaN</strong>, не <strong>0</strong></p>
              <h3>Логическое преобразование</h3>
              <p>Значения, которые интуитивно «пустые», вроде <strong>0</strong>, пустой строки, <strong>null</strong>, <strong>undefined</strong> и <strong>NaN</strong>, становятся <strong>false</strong>.</p>
              <p>Все остальные значения становятся <strong>true</strong>.</p>
              <div class="item">
                <pre>let value = Boolean(1); // true</pre>
              </div>
              <div class="item">
                <pre>let value = Boolean(0); // false</pre>
              </div>
              <div class="item">
                <pre>let value = Boolean("Привет!"); // true</pre>
              </div>
              <div class="item">
                <pre>let value = Boolean(""); // false</pre>
              </div>
              <p class="warning"><strong>"0"</strong> и строки из одних пробелов типа <strong>" "</strong> при логическом преобразовании всегда <strong>true</strong>.</p>
            </div>
          </div>
        </div>

        <div class="grid-item">
          <div class="block">
            <div class="heading" data-bs-toggle="collapse" data-bs-target="#collapseOperators">
              <h2>Операторы</h2>
            </div>
            <div class="collapse show" id="collapseOperators">
              <h3>Операторы присваивания</h3>
              <div class="item">
                <pre>x = y      // x = y -> присваивание
x += y     // x = x + y -> присваивание со сложением
x -= y     // x = x - y -> присваивание с вычитанием
x *= y     // x = x * y -> присваивание с умножением
x /= y     // x = x / y -> присваивание с делением
x %= y     // x = x % y -> присваивание по модулю
x <<= y    // x = x << y -> присваивание с левым сдвигом
x >>= y    // x = x >> y -> присваивание с правым сдвигом
x >>>= y   // x = x >>> y -> присваивание с беззнаковым сдвигом вправо
x &= y     // x = x & y -> присваивание с побитовым AND
x ^= y     // x = x ^ y -> присваивание с побитовым XOR
x |= y     // x = x | y -> присваивание с побитовым OR</pre>
              </div>
              <h3>Деструктуризация</h3>
              <p>Деструктуризации - это выражение, которое позволяет извлекать данные из массивов или объектов, используя синтаксис, который зеркалирует конструкторы массивов и литералы объектов.</p>
              <div class="item">
                <pre>var foo = ["one", "two", "three"];
// без деструктуризации
var one = foo[0];
var two = foo[1];
var three = foo[2];
// с деструктуризацией
var [one, two, three] = foo;</pre>
              </div>
              <h3>Операторы сравнения</h3>
              <p>Операнды могут быть числами, строками, логическими величинами или объектами. Строки сравниваются на основании стандартного лексикографического порядка, используя Unicode-значения</p>
              <div class="item">
                <pre>a == b     // true, если операторы равны
a == b     // true, если операторы равны
a != b     // true, если операторы не равны
a === b    // true, если операторы равны и одинаковый тип
a !== b    // true, если операторы не равны и/или разный тип
a > b      // true, если оператор слева больше
a >= b     // true, если оператор слева больше или равен
a < b      // true, если оператор слева меньше
a <= b     // true, если оператор слева меньше или равен</pre>
              </div>
              <h3>Арифметические операторы</h3>
              <div class="item">
                <pre>12 % 5    // 2 -> остаток от деления
i++       // инкремент (i = i + 1)
i--       // декремент (i = i - 1)
-i        // унарный минус, отрицат значение i
+i        // унарный плюс - приводит i к числу
i ** c    // возводит i в степень c</pre>
              </div>
              <h3>Логические операторы</h3>
              <p>Логическое И - возвращает операнд expr1, если он может быть преобразован в false; в противном случае возвращает операнд expr2. Таким образом, при использовании булевых величин в качестве операндов, оператор && возвращает true, если оба операнда true; в противном случае возвращает false.</p>
              <div class="item">
                <pre>expr1 && expr2</pre>
              </div>
              <p>Логическое ИЛИ - возвращает операнд expr1, если он может быть преобразован в true; в противном случае возвращает операнд expr2. Таким образом, при использовании булевых величин в качестве операндов, оператор || возвращает true, если один из операндов true; если же оба false, то возвращает false.</p>
              <div class="item">
                <pre>expr1 || expr2</pre>
              </div>
              <p>Логическое НЕ - возвращает false, если операнд может быть преобразован в true; в противном случае возвращает true.</p>
              <div class="item">
                <pre>!expr</pre>
              </div>
              <h3>Строковые операторы</h3>
              <div class="item">
                <pre>console.log("my " + "string"); // "my string"</pre>
              </div>
              <div class="item">
                <pre>var mystring = "alpha";
mystring += "bet"; // mystring присваивается "alphabet"</pre>
              </div>
              <h3>Условный (тернарный) оператор</h3>
              <div class="item">
                <pre>condition ? val1 : val2</pre>
              </div>
              <h3>Унарнывй оператор delete</h3>
              <p>Оператор <strong>delete</strong> выполняет удаление объекта, свойства объекта, или элемента массива с заданным индексом. После применения оператора <strong>delete</strong> свойство элемента меняется на <strong>undefined</strong>. Оператор <strong>delete</strong> возвращает <strong>true</strong> если выполнение операции возможно; оператор возвращает <strong>false</strong>, если выполнение операции невозможно.</p>
              <div class="item">
                <pre>delete objectName;
delete objectName.property;
delete objectName[index];
delete property; // допустимо только внутри with</pre>
              </div>
              <p>где <strong>objectName</strong> представляет собой имя объекта, <strong>property</strong> - свойство объекта, а <strong>index</strong> - целое число, указывающее на положение (номер позиции) элемента в массиве.</p>
              <h3>Оператор typeof</h3>
              <p>Оператор <strong>typeof</strong> возвращает строку обозначающую тип невычисленного операнда. Значение <strong>operand</strong> может быть строкой, переменной, дескриптором, или объектом, тип которого следует определить. Скобки вокруг операнда необязательны.</p>
              <div class="item">
                <pre>typeof operand
typeof (operand)</pre>
              </div>
              <div class="item">
                <pre>var today = new Date();
typeof today; // возвращает "object"
                </pre>
              </div>
              <div class="item">
                <pre>typeof null; // возвращает "object"
                </pre>
              </div>
              <div class="item">
                <pre>// Методы и функции
typeof blur; // возвращает "function"
typeof eval; // возвращает "function"
typeof parseInt; // возвращает "function"
typeof shape.split; // возвращает "function"</pre>
              </div>
              <div class="item">
                <pre>// Встроенные объекты
typeof Date; // возвращает "function"
typeof Function; // возвращает "function"
typeof Math; // возвращает "object"
typeof Option; // возвращает "function"
typeof String; // возвращает "function"</pre>
              </div>
              <h3>Оператор void</h3>
              <p>Оператор <strong>void</strong> определяет выражение, которое должно быть вычислено без возвращения результата. <strong>expression</strong> - это выражение JavaScript, требующее вычисления. Скобки вокруг выражения необязательны, но их использование является правилом хорошего тона.</p>
              <div class="item">
                <pre>void (expression)
void expression</pre>
              </div>
              <h3>Оператор отношения in</h3>
              <p>Возвращает true, если указанный объект имеет указанное свойство</p>
              <div class="item">
                <pre>propNameOrNumber in objectName</pre>
              </div>
              <p>где <strong>propNameOrNumber</strong> - строка или числовое выражение, представляющее имя свойства или индекс массива, а <strong>objectName</strong> - имя объекта.</p>
              <h3>Оператор instanceof</h3>
              <p>Возвращает true, если заданный объект является объектом указанного типа</p>
              <div class="item">
                <pre>objectName instanceof objectType</pre>
              </div>
              <p>где <strong>objectName</strong> - имя объекта, тип которого необходимо сравнить с <strong>objectType</strong>, а <strong>objectType</strong> - тип объекта, например, <strong>Date</strong> или <strong>Array</strong>.</p>
              <h3>Оператор this</h3>
              <p>В общем случае this указывает на вызываемый объект, которому принадлежит данный метод.</p>
              <div class="item">
                <pre>this["propertyName"]
this.propertyName</pre>
              </div>
              <h3>Оператор new</h3>
              <p>Используется для создания экземпляра объекта пользовательского типа или одного из встроенных объектов.</p>
              <div class="item">
                <pre>var objectName = new objectType([param1, param2, ..., paramN]);</pre>
              </div>
              <h3>Ключевое слово super</h3>
              <p>Используется, чтобы вызывать функции родительского объекта. Это полезно и с классами для вызова конструктора родителя</p>
              <div class="item">
                <pre>super([arguments]); // вызывает конструктор родителя. super.functionOnParent([arguments]);</pre>
              </div>
              <h3>Spread оператор (расширения)</h3>
              <p>позволяет выражению расширяться в местах с множеством аргументов (для вызовов функций) или множестве элементов (для массивов)</p>
              <div class="item">
                <pre>var parts = ["shoulder", "knees"];
var lyrics = ["head", ...parts, "and", "toes"];</pre>
              </div>
              <div class="item">
                <pre>function f(x, y, z) {}
var args = [0, 1, 2];
f(...args);</pre>
              </div>
              <p><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_precedence#table">Приоритет операторов</a></p>
            </div>
          </div>
        </div>

        <div class="grid-item">
          <div class="block">
            <div class="heading" data-bs-toggle="collapse" data-bs-target="#collapseString">
              <h2>Строки</h2>
            </div>
            <div class="collapse show" id="collapseString">
              <div class="item">
                <pre>let single = 'single-quoted';
let double = "double-quoted";</pre>
              </div>
              <p>Eсли использовать обратные кавычки, то в такую строку мы сможем вставлять произвольные выражения, обернув их в <strong>${…}</strong></p>
              <div class="item">
                <pre>alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3</pre>
              </div>
              <div class="item">
                <pre>var esc = 'I don\'t \n know';   // \n перенос строки
var len = abc.length;           // длина строки</pre>
              </div>
              <p>Метод <strong>includes()</strong> определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого <strong>true</strong> или <strong>false</strong>.</p>
              <div class="item">
                <pre>[1, 2, 3].includes(2) // true
['cat', 'dog'].includes(('at')) // false</pre>
              </div>
              <p>Метод <strong>str.startsWith(searchString[, position])</strong> помогает определить, начинается ли строка с символов указанных в скобках, возвращая, соответственно, <strong>true</strong> или <strong>false</strong>.</p>
              <div class="item">
                <pre>var str = "Быть или не быть...";
str.startsWith("Быть");      // true
str.startsWith("не быть");   // false
str.startsWith("не быть", 9) // true</pre>
              </div>
              <p>Метод <strong>str.endsWith(searchString[, length])</strong> позволяет определить, заканчивается ли строка символами указанными в скобках, возвращая, соответственно, <strong>true</strong> или <strong>false</strong>. <br><strong>length</strong> - необязательный параметр. Позволяет искать внутри строки, обрезая её по диапазону; по умолчанию равен длине строки.</p>
              <div class="item">
                <pre>var str = "Быть или не быть, вот в чём вопрос.";
str.endsWith("вопрос.");  // true
str.endsWith("быть");     // false
str.endsWith("быть", 16); // true</pre>
              </div>
              <p>Метод <strong>trim()</strong> удаляет пробельные символы с начала и конца строки</p>
              <div class="item">
                <pre>'   foo  '.trim()  // 'foo'</pre>
              </div>
              <p>Метод <strong>repeat()</strong> конструирует и возвращает новую строку, содержащую указанное количество соединённых вместе копий строки, на которой он был вызван.</p>
              <div class="item">
                <pre>'абв'.repeat(-1);  // RangeError
'абв'.repeat(0);   // ''
'абв'.repeat(1);   // 'абв'
'абв'.repeat(2);   // 'абвабв'
'абв'.repeat(3.5); // 'абвабвабв' - 3.5 будет преобразовано в целое число</pre>
              </div>
              <h3>Нахождение подстроки str.indexOf(substr, pos)</h3>
              <p>Ищет подстроку <strong>substr</strong> в строке <strong>str</strong>, начиная с позиции <strong>pos</strong> (необязательный параметр), и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений</p>
              <div class="item">
                <pre>let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, чувствителен к регистру

alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1</pre>
              </div>
              <div class="item">
                <pre>let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12, т.к. поиск со 2 позиции</pre>
              </div>
              <p>Чтобы найти все вхождения подстроки, нужно запустить <strong>indexOf</strong> в цикле. Каждый раз, получив очередную позицию, начинаем новый поиск со следующей</p>
              <div class="item">
                <pre>let str = "Ослик Иа-Иа";
let target = "Иа";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}</pre>
              </div>
              <p>Также есть похожий метод <strong>str.lastIndexOf(substr, position)</strong>, который ищет с конца строки к её началу.<br>Он используется тогда, когда нужно получить самое последнее вхождение: перед концом строки или начинающееся до (включительно) определённой позиции.</p>
              <div class="item">
                <pre>abc.lastIndexOf("lmno");</pre>
              </div>
              <h3>Получение подстроки</h3>
              <p><strong>str.slice(start [, end])</strong> - возвращает часть строки от <strong>start</strong> до (не включая) <strong>end</strong>.</p>
              <div class="item">
                <pre>let str = "stringify";
str.slice(0, 5)   // 'strin', символы от 0 до 5 (не включая 5)
str.slice(0, 1)   // 's', от 0 до 1, не включая 1</pre>
              </div>
              <p>Если аргумент <strong>end</strong> отсутствует, <strong>slice</strong> возвращает символы до конца строки</p>
              <div class="item">
                <pre>let str = "stringify";
alert( str.slice(2) ); // 'ringify', с позиции 2 и до конца</pre>
              </div>
              <p>Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки</p>
              <div class="item">
                <pre>let str = "stringify";
// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
alert( str.slice(-4, -1) ); // 'gif'</pre>
              </div>
              <p><strong>str.substring(start [, end])</strong> - возвращает часть строки между <strong>start</strong> и <strong>end</strong> (не включая) <strong>end</strong>. <br>можно задавать <strong>start</strong> больше <strong>end</strong>. <br>Если <strong>start</strong> больше <strong>end</strong>, то метод <strong>substring</strong> сработает так, как если бы аргументы были поменяны местами. <br>Отрицательные значения <strong>substring</strong>, в отличие от <strong>slice</strong>, не поддерживает, они интерпретируются как <strong>0</strong></p>
              <div class="item">
                <pre>let str = "stringify";
// для substring эти два примера — одинаковы
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"</pre>
              </div>
              <p><strong>str.substr(start [, length])</strong> - возвращает часть строки от <strong>start</strong> длины <strong>length</strong></p>
              <div class="item">
                <pre>let str = "stringify";
// 'ring', получаем 4 символа, начиная с позиции 2
alert( str.substr(2, 4) );</pre>
              </div>
              <p>Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца</p>
              <div class="item">
                <pre>let str = "stringify";
// 'gi', получаем 2 символа, начиная с позиции 4 с конца строки
alert( str.substr(-4, 2) );</pre>
              </div>
              <p>Метод <strong>replace()</strong> выполняет внутри строки поиск с использованием регулярного выражения (объект <strong>RegExp</strong>), или строкового значения и возвращает новую строку, в которой будут заменены найденные значения.</p>
              <div class="item">
                <pre>'11-31-56'.replace("-", ":");  // '11:31:56'</pre>
              </div>
              <p>Когда первый аргумент метода <strong>replace</strong> является строкой, он заменяет только первое совпадение!<br>Чтобы заменить все вхождения, нужно воспользоваться флагом <strong>g</strong> (eсли у регулярного выражения есть флаг <strong>g</strong>, то он возвращает массив всех совпадений, флаг <strong>i</strong> делает регулярное выражение регистронезависимым).</p>
              <div class="item">
                <pre>'11-31-56'.replace( /-/g, ":" );             // '11:31:56'
'Как твои дела?'.replace(/твои/gi, 'ваши');  // 'Как ваши дела?'
'Привет Пока'..replace(/(\w+)\s(\w+)/, '$2 $1'); // 'Пока Привет'</pre>
              </div>
              <div class="item">
                <pre>abc.toUpperCase();              // к верхнему регистру
abc.toLowerCase();              // к нижнему регистру
abc.concat(" ", str2);          // abc + " " + str2</pre>
              </div>
              <p>Метод <strong>charAt(index)</strong> возвращает указанный символ из строки. <strong>index</strong> - целое число от 0 до длины строки минус 1</p>
              <div class="item">
                <pre>'abcd'.charAt(2);               // 'c'</pre>
              </div>
              <p>Для получения символа используем <strong>[]</strong> или метод <strong>at</strong></p>
              <div class="item">
                <pre>'abcd'[2];                      // 'c'
'abcd'.at(1);                   // 'b'</pre>
              </div>
              <p>Метод <strong>charCodeAt()</strong> возвращает числовое значение Юникода для символа по указанному индексу</p>
              <div class="item">
                <pre>'abcd'.charCodeAt(2);            // "c" -> 99</pre>
              </div>
              <p>Метод <strong>split</strong> разбивает строки в массив по указанному в первом параметре разделителю. Если он не задан - вернется вся строка. Если он задан как пустые кавычки, то каждый символ строки попадет в отдельный элемент массива. Вторым необязательным параметром можно указать максимальное количество элементов в получившемся массиве.</p>
              <div class="item">
                <pre>'abcd'.split(",");                 // ['abcd']
'abcd'.split("");                  // ['a', 'b', 'c', 'd']
'ab-cd-ef'.split('-');             // ['ab', 'cd', 'ef']
'ab-cd-ef'.split('-', 2);          // ['ab', 'cd']</pre>
              </div>
              <p>Метод <strong>numObj.toString([radix])</strong> возвращает строковое представление указанного объекта <strong>Number</strong>. radix - необязательный параметр, целое число между 2 и 36, определяющее основание системы счисления, используемой для представления числового значения.</p>
              <div class="item">
                <pre>(6).toString(2)); // Выведет '110'
(254).toString(16); // Выведет 'fe'</pre>
              </div>
              <h3>JSON.stringify(obj)</h3>
              <p>Обычно <strong>JSON</strong> используется для обмена данными с сервером.<br>
                При отправке на сервер данные всегда передаются в виде строки.<br>
                Чтобы преобразовать объект JavaScript в строку, используется функция <strong>JSON.stringify()</strong>.</p>
              <div class="item">
                <pre>JSON.stringify({ "name":"John", "age":30}) // '{"name":"John","age":30}'</pre>
              </div>
              <p><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String">Все методы работы со строками</a></p>
            </div>
          </div>
        </div>

        <div class="grid-item">
          <div class="block">
            <div class="heading" data-bs-toggle="collapse" data-bs-target="#collapseOperators">
              <h2>Циклы</h2>
            </div>
            <div class="collapse show" id="collapseOperators">
              <h3>Цикл For</h3>
              <div class="item">
                <pre>for (let i = 0; i < 3; i++) {
  alert(i); // выведет 0, затем 1, затем 2
}</pre>
              </div>
              <div class="item">
                <pre>var sum = 0;
for (var i = 0; i < a.length; i++) {
  sum + = a[i];
}               // парсинг (разбор) массива</pre>
              </div>
              <p>Любая часть <strong>for</strong> может быть пропущена</p>
              <p>Оператор <strong>for...of</strong> выполняет цикл обхода итерируемых объектов (включая <strong>Array</strong>, <strong>Map</strong>, <strong>Set</strong>, объект аргументов и подобных), вызывая на каждом шаге итерации операторы для каждого значения из различных свойств объекта.</p>
              <div class="item">
                <pre>let iterable = [10, 20, 30];

for (let value of iterable) {
  value += 1;
  console.log(value);  // выведет 10, затем 20, затем 30
}</pre>
              </div>
              <h3>Цикл While</h3>
              <div class="item">
                <pre>let i = 0;

while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}</pre>
              </div>
              <h3>Цикл «do…while»</h3>
              <div class="item">
                <pre>let i = 0;

do {
  alert( i ); // выведет 0, затем 1, затем 2
  i++;
} while (i < 3);</pre>
              </div>
              <h3>Прерывание цикла: «break»</h3>
              <div class="item">
                <pre>for (var i = 0; i < 10; i++) {
if (i == 5) { break; }          // стоп и выход из цикла
document.write(i + ", ");       // последнее выведенное число - 4
}</pre>
              </div>
              <h3>Переход к следующей итерации: «continue»</h3>
              <div class="item">
                <pre>for (var i = 0; i < 10; i++) {
if (i == 5) { continue; }       // пропуск остальных операторов итерации
document.write(i + ", ");       // пропустит 5
}</pre>
              </div>
              <p>Нельзя использовать <strong>break/continue</strong> справа от оператора <strong>?</strong></p>
            </div>
          </div>
        </div>
      </div>






    </main>
    <!-- main content end -->
    <!-- footer begin -->
    <footer id="footer">
      <div class="box">
        <strong class="logo-js">Шпаргалка по JavaScript</strong>
        <ul class="nav">
          <li><a href="https://learn.javascript.ru/" target="_blank">Учебник</a></li>
          <li><a href="http://jsbin.com/?html,css,js,console,output" target="_blank">Редактор</a></li>
        </ul>
      </div>
      <p class="copyright">©️ 2023 Дмитрий Андриянов</p>
    </footer>
    <!-- footer end -->
  <!-- js -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ENjdO4Dr2bkBIFxQpeoTz1HIcje39Wm4jDKdf19U8gI4ddQ3GYNS7NTKfAdVQSZe" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
  <script src="js/script.js"></script>
</body>
</html>
